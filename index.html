<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Pixel Canvas</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Press Start 2P font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800;600&display=swap');
        
        body { 
            font-family: 'Press Start 2P', cursive; 
        }

        /* Custom styles for the grid */
        #pixel-grid {
            display: grid;
            width: 100%;
            height: 100%;
            grid-template-columns: var(--grid-columns);
            grid-template-rows: var(--grid-columns);
            aspect-ratio: 1 / 1;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #f3f4f6; /* Light gray background */
        }

        .pixel-cell {
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: background-color 0.1s;
            cursor: crosshair; 
        }

        /* Ensure inputs, modals, and user info use a readable font */
        .readable-font {
            font-family: 'Inter', sans-serif;
        }
        
        .btn-style {
            transition: all 0.15s ease-in-out;
            transform: translateY(0);
        }
        .btn-style:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .btn-style:active {
            transform: translateY(1px);
        }

        .grid-container {
            max-width: 90vw;
            width: 100%;
            margin-bottom: 2rem;
        }

        @media (min-width: 768px) {
            .grid-container {
                display: flex; /* Flex is better for centering canvas inside grid */
                justify-content: center;
                align-items: center;
                width: 100%;
                max-width: 100%;
            }
            .content-area {
                display: grid;
                grid-template-columns: 2fr 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center p-4 min-h-screen readable-font">

    <div class="w-full max-w-6xl">
        <header class="text-center mb-8">
            <h1 class="text-2xl sm:text-3xl font-extrabold text-indigo-700 font-[Press Start 2P]">Real-Time Pixel Canvas</h1>
            <p class="text-gray-500 mt-3 text-xs">Collaborate on a single, shared canvas.</p>
            
            <!-- Banned User Warning Banner -->
            <div id="banned-banner" class="hidden readable-font p-4 bg-red-100 border-l-4 border-red-500 text-red-700 my-4 rounded-lg shadow-lg max-w-lg mx-auto">
                <p class="font-bold text-sm" id="banned-title">Account Disabled / Banned</p>
                <p class="text-xs mt-1" id="banned-message">Your account has been permanently disabled by an administrator. You may only view the canvas.</p>
                <button id="resign-in-btn" class="mt-3 text-xs font-semibold px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 transition btn-style">
                    Re-sign In with Last Account
                </button>
            </div>


            <!-- Authentication Status and Controls -->
            <div id="auth-controls" class="mt-4 flex flex-col items-center gap-3">
                <!-- User ID display for collaboration -->
                <div id="user-info" class="text-xs text-gray-700 p-2 bg-white rounded-lg shadow-inner w-full sm:w-auto border border-gray-200">
                    Connecting to Firebase...
                </div>
                
                <!-- Email/Password Auth -->
                <div id="email-auth-area" class="w-full max-w-xs p-4 bg-white rounded-xl shadow-md border border-gray-100 grid grid-cols-2 gap-2">
                    <input type="email" id="email-input" placeholder="Email" class="col-span-2 p-2 border border-gray-300 rounded-lg text-sm focus:ring-indigo-500 focus:border-indigo-500">
                    <input type="password" id="password-input" placeholder="Password" class="col-span-2 p-2 border border-gray-300 rounded-lg text-sm focus:ring-indigo-500 focus:border-indigo-500">
                    
                    <button id="sign-up-btn" class="py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition duration-150 btn-style text-xs">
                        Sign Up
                    </button>
                    <button id="email-sign-in-btn" class="py-2 bg-indigo-700 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-800 transition duration-150 btn-style text-xs">
                        Sign In
                    </button>
                    <!-- NEW: Password Reset Button -->
                    <button id="password-reset-btn" class="col-span-2 mt-2 text-xs text-indigo-500 hover:text-indigo-700 font-semibold transition duration-150 py-1 bg-gray-50 rounded-lg border border-gray-200 btn-style">
                        Forgot Password?
                    </button>
                </div>

                <!-- Anonymous and Google Auth -->
                <div id="social-auth-area" class="flex flex-wrap justify-center gap-2 mt-2 w-full max-w-xs">
                    <button id="google-sign-in-btn" class="flex-1 py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-150 btn-style text-xs min-w-[120px]">
                        Google Sign In
                    </button>
                    <button id="anonymous-sign-in-btn" class="flex-1 py-2 px-4 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-150 btn-style text-xs min-w-[120px]">
                        Anonymous Sign In
                    </button>
                </div>
                
                <!-- SIGN OUT BUTTON -->
                <button id="sign-out-btn" class="w-full max-w-xs py-2 bg-gray-400 text-white font-semibold rounded-lg shadow-md hover:bg-gray-500 transition duration-150 hidden btn-style text-xs mt-2">
                    Sign Out
                </button>
            </div>
        </header>
        
        <!-- Main Content Area: Canvas and Leaderboard -->
        <div class="content-area">
            <!-- Left Column: Canvas and Controls -->
            <div>
                <!-- Controls Panel -->
                <div class="bg-white p-5 md:p-8 rounded-xl shadow-2xl mb-6 border border-indigo-100 flex flex-col gap-4">
                    
                    <!-- Grid and Color Pickers -->
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        
                        <!-- Color Picker -->
                        <div class="col-span-1">
                            <label for="color-picker" class="block text-xs font-medium text-gray-700 mb-2">Current Color</label>
                            <input type="color" id="color-picker" value="#ff0000" class="w-full h-10 border border-gray-300 rounded-lg p-1 shadow-sm transition duration-150 ease-in-out hover:shadow-md cursor-pointer">
                        </div>

                        <!-- Grid Size Input (Read-only after initialization) -->
                        <div class="col-span-1">
                            <label for="grid-size" class="block text-xs font-medium text-gray-700 mb-2">Grid Size (N x N)</label>
                            <input type="number" id="grid-size" value="32" min="8" max="64" class="w-full h-10 border border-gray-300 bg-gray-200 rounded-lg p-2 text-center shadow-inner text-gray-500" readonly>
                        </div>

                        <!-- Clear Button -->
                        <div class="col-span-1 flex items-end">
                            <button id="clear-btn" class="w-full py-2 px-4 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-150 ease-in-out text-xs btn-style">
                                Clear Canvas
                            </button>
                        </div>
                    </div>

                    <!-- Status Message -->
                    <p class="text-center text-sm text-indigo-500 mt-2 text-xs">
                        <span id="draw-status-message">Sign in to start drawing!</span> Changes are synced immediately.
                    </p>
                </div>
                
                <!-- Canvas Area -->
                <div class="flex justify-center grid-container mx-auto">
                    <div id="pixel-grid" class="border border-gray-500 rounded-xl overflow-hidden shadow-2xl">
                        <!-- Grid cells will be injected here by JS -->
                        <div class="flex items-center justify-center h-full text-gray-400 text-sm">
                            Connecting to shared canvas...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Leaderboard and Presence -->
            <div class="w-full">
                <!-- NEW: Who's Online -->
                <div class="bg-white p-6 rounded-xl shadow-2xl mb-6 border border-green-100">
                    <h2 class="text-xl font-bold text-green-600 mb-2 text-center font-[Press Start 2P]">üåé Who's Online</h2>
                    <p id="online-count" class="text-center text-sm font-semibold text-gray-500 mb-4 readable-font">0 people currently online</p>
                    <ul id="online-users-list" class="space-y-1 max-h-40 overflow-y-auto readable-font">
                        <li class="text-gray-500 text-xs text-center">Loading presence data...</li>
                    </ul>
                </div>

                <div class="bg-white p-6 rounded-xl shadow-2xl border border-yellow-100">
                    <h2 class="text-xl font-bold text-yellow-600 mb-4 text-center font-[Press Start 2P]">üèÜ Top Contributors</h2>
                    <ul id="leaderboard-list" class="space-y-3 readable-font">
                        <li class="text-gray-500 text-sm text-center">Loading scores...</li>
                    </ul>
                </div>
            </div>
            
        </div>
        
    </div>

    <!-- Message Modal -->
    <div id="modal-container" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-3xl max-w-sm w-full transform transition-all duration-300 scale-95 opacity-0" id="modal-content">
            <h3 id="modal-title" class="text-xl font-bold mb-3 text-indigo-700"></h3>
            <p id="modal-message" class="text-gray-700 mb-4"></p>
            <button id="modal-close-btn" class="w-full py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition btn-style">Close</button>
        </div>
    </div>


    <!-- Firebase Core and Services -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            onAuthStateChanged, 
            signInWithPopup, 
            GoogleAuthProvider, 
            signOut,
            signInAnonymously,
            signInWithCustomToken,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            sendPasswordResetEmail
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            onSnapshot,
            collection, 
            query, 
            setLogLevel,
            increment, 
            serverTimestamp 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Firebase Configuration and Globals ---

        // The App ID for Firestore pathing (MANDATORY for security rules)
        const PIXEL_APP_ID = typeof __app_id !== 'undefined' ? __app_id : 'default-pixel-app-id';
        // Parse the configuration provided by the environment, defensively checking
        const firebaseConfig = typeof __firebase_config !== 'undefined' && __firebase_config !== 'null' 
            ? JSON.parse(__firebase_config) 
            : {};
        
        const BANNED_FLAG_KEY = `${PIXEL_APP_ID}_isBanned`; 
        const BANNED_METHOD_KEY = `${PIXEL_APP_ID}_lastMethod`;
        const BANNED_EMAIL_KEY = `${PIXEL_APP_ID}_lastEmail`;

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let userId = null;
        let unsubscribeCanvasSnapshot = null;
        let unsubscribeLeaderboardSnapshot = null; 
        let unsubscribePresenceSnapshot = null;

        // --- Application State & Constants ---

        let currentColor = document.getElementById('color-picker').value;
        let gridSize = 32; 
        const CANVAS_COLLECTION = 'pixel_art';
        const SHARED_CANVAS_DOC_ID = 'shared_canvas_001'; 
        const LEADERBOARD_COLLECTION = 'leaderboard'; 
        const PRESENCE_COLLECTION = 'presence';
        // 60 seconds threshold for being considered "online"
        const ONLINE_THRESHOLD_MS = 60 * 1000; 

        // --- DOM elements ---
        const gridContainer = document.getElementById('pixel-grid');
        const colorPicker = document.getElementById('color-picker');
        const sizeInput = document.getElementById('grid-size');
        const clearBtn = document.getElementById('clear-btn');
        const userInfo = document.getElementById('user-info');
        const signUpBtn = document.getElementById('sign-up-btn');
        const emailSignInBtn = document.getElementById('email-sign-in-btn');
        const passwordResetBtn = document.getElementById('password-reset-btn'); 
        const googleSignInBtn = document.getElementById('google-sign-in-btn');
        const anonymousSignInBtn = document.getElementById('anonymous-sign-in-btn');
        const signOutBtn = document.getElementById('sign-out-btn');
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');
        const drawStatusMessage = document.getElementById('draw-status-message');
        const leaderboardList = document.getElementById('leaderboard-list'); 
        const bannedBanner = document.getElementById('banned-banner');
        const resignInBtn = document.getElementById('resign-in-btn');
        const socialAuthArea = document.getElementById('social-auth-area');
        const emailAuthArea = document.getElementById('email-auth-area');
        const bannedTitle = document.getElementById('banned-title');
        const bannedMessage = document.getElementById('banned-message');
        const onlineCount = document.getElementById('online-count'); 
        const onlineUsersList = document.getElementById('online-users-list'); 
        
        // Modal elements
        const modalContainer = document.getElementById('modal-container');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        
        // Drawing State
        let isDrawing = false;
        let lastPaintedIndex = -1; 

        // --- Persistence (localStorage) ---
        /** Saves the ban status and last sign-in method/email. */
        function setBannedState(isBanned, method = null, email = null) {
            if (isBanned) {
                localStorage.setItem(BANNED_FLAG_KEY, 'true');
                if (method) localStorage.setItem(BANNED_METHOD_KEY, method);
                if (email) localStorage.setItem(BANNED_EMAIL_KEY, email);
            } else {
                localStorage.removeItem(BANNED_FLAG_KEY);
                localStorage.removeItem(BANNED_METHOD_KEY);
                localStorage.removeItem(BANNED_EMAIL_KEY);
            }
        }

        function isUserLocallyBanned() {
            return localStorage.getItem(BANNED_FLAG_KEY) === 'true';
        }
        
        /**
         * Disables/enables all authentication buttons to prevent multiple simultaneous submissions.
         * Also adds a visual indicator for processing status on the email buttons.
         */
        function setAuthButtonsDisabled(disabled) {
            // Disable all authentication buttons
            signUpBtn.disabled = disabled;
            emailSignInBtn.disabled = disabled;
            passwordResetBtn.disabled = disabled;
            googleSignInBtn.disabled = disabled;
            anonymousSignInBtn.disabled = disabled;
            
            if (disabled) {
                signUpBtn.textContent = 'Processing...';
                emailSignInBtn.textContent = 'Processing...';
            } else {
                signUpBtn.textContent = 'Sign Up';
                emailSignInBtn.textContent = 'Sign In';
            }
        }


        // --- Utility Functions & UI ---

        function showModal(title, message, isConfirmation = false) {
            // Reset modal content to standard layout first
            modalContent.innerHTML = `
                <h3 id="modal-title" class="text-xl font-bold mb-3 text-indigo-700"></h3>
                <p id="modal-message" class="text-gray-700 mb-4"></p>
                <button id="modal-close-btn-standard" class="w-full py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition btn-style">Close</button>
            `;
            
            // Update standard elements
            modalContent.querySelector('#modal-title').textContent = title;
            modalContent.querySelector('#modal-message').textContent = message;
            modalContent.querySelector('#modal-close-btn-standard').onclick = closeModal;

            modalContainer.classList.remove('hidden');
            modalContainer.classList.add('flex');
            setTimeout(() => {
                modalContent.classList.remove('scale-95', 'opacity-0');
                modalContent.classList.add('scale-100', 'opacity-100');
            }, 10);
        }

        function closeModal() {
            modalContent.classList.remove('scale-100', 'opacity-100');
            modalContent.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modalContainer.classList.remove('flex');
                modalContainer.classList.add('hidden');
            }, 300);
        }

        /** Hides auth forms and shows the ban banner based on stored data, disabling all sign-in elements. */
        function handleBannedUserUI() {
            const method = localStorage.getItem(BANNED_METHOD_KEY) || 'Unknown';
            const email = localStorage.getItem(BANNED_EMAIL_KEY);

            // Set banner content
            bannedTitle.textContent = "Account Disabled";
            
            if (email && method !== 'anonymous') {
                bannedMessage.textContent = `The account associated with ${email} is disabled. Click 'Re-sign In' to check if the ban has been lifted.`;
            } else if (method === 'anonymous') {
                bannedMessage.textContent = `Your last Anonymous ID was disabled. Click 'Re-sign In' to check your status.`;
            } else {
                bannedMessage.textContent = `Your last account was disabled. Click 'Re-sign In with Last Account' to check your status.`;
            }

            // Hide sign-in options, show banner
            emailAuthArea.classList.add('hidden');
            socialAuthArea.classList.add('hidden');
            signOutBtn.classList.add('hidden');
            bannedBanner.classList.remove('hidden');
            
            // CRITICAL: Explicitly disable all sign-in elements when permanently banned
            emailInput.disabled = true;
            passwordInput.disabled = true;
            setAuthButtonsDisabled(true); // Ensures all buttons are disabled visually and functionally

            // Update info message to reflect banned status
            userInfo.innerHTML = '<span class="text-red-600 font-bold">ACCESS DENIED.</span> You can only view the canvas.';
            drawStatusMessage.textContent = "You are banned and cannot draw.";
            clearBtn.disabled = true; 
            
            // If banned, stop any attempts to draw
            isDrawing = false;
        }

        /** Updates the UI based on the current authentication state and local ban status. */
        function updateUI(user) {
            console.log(`[UI Update] User status: ${user ? 'Signed In' : 'Signed Out'}. Is Locally Banned: ${isUserLocallyBanned()}`);

            if (isUserLocallyBanned()) {
                handleBannedUserUI();
                return;
            }
            // Ensure the banner is hidden if not banned
            bannedBanner.classList.add('hidden');


            if (user) {
                // Determine display name
                let displayName;
                if (user.email) {
                    displayName = user.email.split('@')[0]; 
                } else if (user.isAnonymous) {
                    displayName = 'Anonymous';
                } else {
                    displayName = 'Authenticated User';
                }

                userId = user.uid;
                
                userInfo.innerHTML = `You are: <span class="font-bold text-indigo-600">${displayName}</span> | ID: <span class="font-mono text-xs text-indigo-500">${userId}</span>`;
                drawStatusMessage.textContent = "You can draw!";
                
                // Block anonymous clear button action visually
                clearBtn.disabled = false; 

                // Hide sign-in options, show sign-out
                emailAuthArea.classList.add('hidden');
                socialAuthArea.classList.add('hidden');
                signOutBtn.classList.remove('hidden'); // Show Sign Out button
                
                // Disable all sign-in elements when signed in (they are hidden anyway)
                emailInput.disabled = true;
                passwordInput.disabled = true;
                setAuthButtonsDisabled(true); // Ensures all buttons are disabled visually and functionally
                
            } else {
                userId = null;
                userInfo.textContent = "You are currently viewing only. Please sign in to draw.";
                drawStatusMessage.textContent = "Sign in to start drawing!";
                clearBtn.disabled = true; 
                
                // Show sign-in options, hide sign-out
                emailAuthArea.classList.remove('hidden');
                socialAuthArea.classList.remove('hidden');
                signOutBtn.classList.add('hidden'); // Hide Sign Out button
                
                // Re-enable all sign-in elements when logged out
                emailInput.disabled = false;
                passwordInput.disabled = false;
                setAuthButtonsDisabled(false); // Re-enable all buttons
            }
        }

        // --- Authentication Handlers ---

        /** Base function to handle errors, especially the ban error. */
        function handleAuthError(error, method, email = null) {
            console.error(`${method} Auth Error:`, error);
            
            let title = "Sign In Failed";
            let message = `Error during ${method} sign-in: ${error.message}`;

            if (error.code === 'auth/user-disabled') {
                title = "Access Denied: Account Disabled";
                message = "This account has been disabled or banned by an administrator. The sign-in form is now hidden.";
                
                // CRITICAL: Set persistent ban state
                setBannedState(true, method, email);
                handleBannedUserUI();
            }

            showModal(title, message);
        }


        async function handleEmailSignUp() {
            const email = emailInput.value;
            const password = passwordInput.value;
            if (isUserLocallyBanned()) { showModal("Access Denied", "Your local ban status must be reset before attempting sign-in."); return; }
            if (!email || password.length < 6) {
                showModal("Input Error", "Please provide a valid email and a password of at least 6 characters.");
                return;
            }
            
            setAuthButtonsDisabled(true); // Disable all buttons while processing
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                showModal("Success!", "Account created and signed in successfully. Happy drawing!");
            } catch (error) {
                handleAuthError(error, 'email', email);
            } finally {
                setAuthButtonsDisabled(false); // Re-enable all buttons
            }
        }

        async function handleEmailSignIn() {
            const email = emailInput.value;
            const password = passwordInput.value;
            if (isUserLocallyBanned()) { showModal("Access Denied", "Your local ban status must be reset before attempting sign-in."); return; }
            if (!email || !password) {
                showModal("Input Error", "Please enter both email and password.");
                return;
            }
            
            setAuthButtonsDisabled(true); // Disable all buttons while processing
            try {
                await signInWithEmailAndPassword(auth, email, password);
                setBannedState(false); // Clear ban status if successful sign in
                showModal("Success!", "Signed in with email/password. Happy drawing!");
            } catch (error) {
                handleAuthError(error, 'email', email);
            } finally {
                setAuthButtonsDisabled(false); // Re-enable all buttons
            }
        }
        
        /** Handles the password reset process. */
        async function handlePasswordReset() {
            const email = emailInput.value;
            if (isUserLocallyBanned()) { showModal("Access Denied", "Your local ban status must be reset before attempting password reset."); return; }
            if (!email) {
                showModal("Input Required", "Please enter your email address in the field above to reset your password.");
                return;
            }

            setAuthButtonsDisabled(true); // Disable all buttons while processing
            try {
                await sendPasswordResetEmail(auth, email);
                showModal("Password Reset Email Sent", `A password reset link has been sent to ${email}. Please check your inbox (and spam folder).`);
                emailInput.value = ''; // Clear email field after success
            } catch (error) {
                console.error("Password Reset Error:", error);
                let message = `Failed to send reset email: ${error.message}`;
                
                // Specific error handling for non-existent user
                if (error.code === 'auth/user-not-found') {
                    message = `No user found for email: ${email}. Please check the address and try again.`;
                }

                // If it's a ban error, use the full handler, otherwise show specific message
                if (error.code === 'auth/user-disabled') {
                    handleAuthError(error, 'Password Reset', email);
                } else {
                     showModal("Password Reset Failed", message);
                }
            } finally {
                 setAuthButtonsDisabled(false); // Re-enable all buttons
            }
        }


        async function handleGoogleSignIn() {
            if (!auth) return;
            if (isUserLocallyBanned()) { showModal("Access Denied", "Your local ban status must be reset before attempting sign-in."); return; }
            
            // NOTE: We don't disable social buttons here because signInWithPopup handles modal/blocking internally.
            const provider = new GoogleAuthProvider();
            try {
                const result = await signInWithPopup(auth, provider);
                const email = result.user.email;
                setBannedState(false); // Clear ban status if successful sign in
                showModal("Success!", `Signed in with Google (${email}). Happy drawing!`);
            } catch (error) {
                handleAuthError(error, 'google');
            }
        }

        async function handleAnonymousSignIn() {
            if (!auth) return;
            if (isUserLocallyBanned()) { showModal("Access Denied", "Your local ban status must be reset before attempting sign-in."); return; }
            
            // NOTE: We don't disable other buttons for Anonymous sign-in as it's a fast, single operation.
            try {
                await signInAnonymously(auth);
                setBannedState(false); // Clear ban status if successful sign in
                showModal("Welcome!", "You are signed in anonymously and can now collaborate.");
            } catch (error) {
                handleAuthError(error, 'anonymous');
            }
        }
        
        /** Attempts to re-sign the user in using the stored method/email. */
        async function handleResignInAttempt() {
            const method = localStorage.getItem(BANNED_METHOD_KEY);
            const email = localStorage.getItem(BANNED_EMAIL_KEY);

            // Temporarily clear local ban state to allow the sign-in functions to run
            setBannedState(false);
            bannedBanner.classList.add('hidden'); 
            
            if (method === 'google') {
                // Re-enable elements needed for UI if Google fails and we go back to logged out state
                updateUI(null); 
                await handleGoogleSignIn();
            } else if (method === 'anonymous') {
                // Re-enable elements needed for UI if Anonymous fails and we go back to logged out state
                updateUI(null);
                await handleAnonymousSignIn();
            } else if (method === 'email' && email) {
                // For email, we must ask for the password. Restore UI and prompt.
                emailInput.value = email;
                passwordInput.value = ''; // Clear password field
                updateUI(null); // Re-show the login forms (and re-enable fields)
                
                showModal("Password Required", `Please enter the password for ${email} and click 'Sign In' to check if your ban has been lifted.`);
                
            } else {
                showModal("Error", "Could not determine last sign-in method. Please try signing in manually.");
                updateUI(null); 
            }
        }


        /**
         * Enhanced sign-out handler with robust defensive checks.
         */
        async function handleSignOut() {
            if (!auth) {
                console.error("[AUTH] Sign-Out Error: Auth object is not initialized.");
                showModal("Sign-Out Failed", "The authentication system is not ready.");
                return;
            }
            
            // CRITICAL CHECK: Ensure a user is actually signed in
            if (!auth.currentUser) {
                console.warn("[AUTH] Sign-Out attempted but no user is currently signed in.");
                showModal("Sign-Out Failed", "You are not currently signed in.");
                // Ensure UI is updated to logged-out state
                updateUI(null);
                return;
            }
            
            const currentUid = auth.currentUser.uid;
            console.log(`[AUTH] Attempting sign-out for user ID: ${currentUid}`);

            try {
                // Perform the actual sign out
                await signOut(auth); 
                
                // Provide immediate user feedback upon successful sign out
                showModal("Signed Out", "You are now viewing the canvas only.");
                
            } catch (error) {
                console.error("[AUTH] FATAL Sign-Out failure:", error);
                showModal("Sign-Out Failed", `Error during sign-out: ${error.message}.`);
            }
            // The onAuthStateChanged listener will handle the final UI state update.
        }

        // --- Firebase Paths, Setup, Canvas, Leaderboard, and Presence Logic ---

        /** Generates the document path for the single shared canvas. */
        function getCanvasDocRef() {
            if (!db) return null;
            // Public path for collaborative canvas data
            // Path: /artifacts/{appId}/public/data/pixel_art/shared_canvas_001
            return doc(db, 'artifacts', PIXEL_APP_ID, 'public', 'data', CANVAS_COLLECTION, SHARED_CANVAS_DOC_ID);
        }
        
        /** Generates the document path for a specific user's leaderboard score. */
        function getLeaderboardDocRef(uid) {
            if (!db || !uid) return null;
            // Public path for collaborative leaderboard data
            // Path: /artifacts/{appId}/public/data/leaderboard/{uid}
            return doc(db, 'artifacts', PIXEL_APP_ID, 'public', 'data', LEADERBOARD_COLLECTION, uid);
        }

        /** Generates the document path for a specific user's presence record. */
        function getPresenceDocRef(uid) {
            if (!db || !uid) return null;
            // Public path for presence data
            // Path: /artifacts/{appId}/public/data/presence/{uid}
            return doc(db, 'artifacts', PIXEL_APP_ID, 'public', 'data', PRESENCE_COLLECTION, uid);
        }

        function setupFirebase() {
            setLogLevel('debug');

            // Defensive check for configuration integrity (Addresses initial error scenario)
            if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
                console.error("Firebase Initialization Error: Configuration object is missing or invalid. Real-time features disabled.");
                userInfo.textContent = "Error initializing Firebase: Config missing. View-only mode.";
                // We stop here and run in view-only mode if initialization fails.
                return; 
            }
            
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Initial sign-in with custom token if available
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                const attemptSignIn = async () => {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (e) {
                        console.error("Initial sign-in failed. Proceeding with unauthenticated state.", e);
                    }
                };

                onAuthStateChanged(auth, (user) => {
                    updateUI(user);
                    
                    if (db) {
                        // Start/Restart syncs when auth state changes 
                        startRealTimeCanvasSync();
                        startRealTimeLeaderboardSync(); 
                        startRealTimePresenceSync();
                    }
                    console.log("[AUTH] Firebase Auth State changed. Current User ID:", user ? user.uid : 'None (Viewer only)');
                });

                // Attempt initial sign-in
                attemptSignIn();


            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                userInfo.textContent = "Error initializing Firebase. See console.";
                showModal("Setup Error", "Failed to initialize the database. Real-time features are disabled. (Generic Init Error)");
            }
        }

        /** Renders the grid based on the provided art data. */
        function renderGrid(artData) {
            const newSize = artData.size || gridSize;
            const colors = Array.isArray(artData.colors) && artData.colors.length === (newSize * newSize) 
                ? artData.colors 
                : Array(newSize * newSize).fill('#ffffff');

            gridSize = newSize;
            sizeInput.value = newSize;

            if (gridContainer.children.length !== (newSize * newSize)) {
                gridContainer.innerHTML = '';
                gridContainer.style.setProperty('--grid-columns', `repeat(${newSize}, 1fr)`);

                for (let i = 0; i < newSize * newSize; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('pixel-cell');
                    cell.dataset.index = i;
                    gridContainer.appendChild(cell);
                }
            }

            const cells = gridContainer.querySelectorAll('.pixel-cell');
            cells.forEach((cell, i) => {
                if (i < colors.length) {
                    cell.style.backgroundColor = colors[i];
                }
            });
        }
        
        /** Starts the Firestore real-time listener for the Canvas. */
        function startRealTimeCanvasSync() {
            if (unsubscribeCanvasSnapshot) {
                // If already subscribed, unsubscribe to clear old listener
                unsubscribeCanvasSnapshot();
                unsubscribeCanvasSnapshot = null;
            }
            
            // CRITICAL FIX: Only subscribe if a user is authenticated (required by security rules)
            if (!auth.currentUser) {
                console.warn("[Firestore] Skipping Canvas sync: User is unauthenticated. Waiting for sign-in.");
                gridContainer.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400 text-sm">Waiting for authentication to load canvas...</div>';
                return;
            }

            const docRef = getCanvasDocRef();
            if (!docRef) return;

            unsubscribeCanvasSnapshot = onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const artData = docSnap.data();
                    renderGrid(artData);
                } else {
                    // Initialize the canvas if it doesn't exist
                    renderGrid({ size: gridSize, colors: Array(gridSize * gridSize).fill('#ffffff') });
                    
                    if (auth.currentUser) { // Only attempt to create if a user is signed in
                        setDoc(docRef, {
                            size: gridSize,
                            colors: Array(gridSize * gridSize).fill('#ffffff'),
                            timestamp: serverTimestamp(),
                            lastEditor: auth.currentUser.uid
                        }).catch(e => console.error("Error creating initial canvas:", e));
                    }
                }
            }, (error) => {
                console.error(`Firestore Canvas Listener Error (User: ${auth.currentUser ? auth.currentUser.uid : 'N/A'}):`, error);
            });
        }


        /** Helper function to determine display name for leaderboard/presence. */
        function getDisplayName(user) {
            if (user.email) return user.email.split('@')[0];
            if (user.isAnonymous) return `Anon-${user.uid.substring(0, 8)}`;
            return 'Contributor';
        }

        /** Updates the user's presence document (lastSeen timestamp). */
        async function updatePresence(user, displayName) {
            if (!db || !user || !user.uid) return;
            const presenceDocRef = getPresenceDocRef(user.uid);
            
            try {
                await setDoc(presenceDocRef, {
                    uid: user.uid,
                    displayName: displayName,
                    lastSeen: serverTimestamp(),
                }, { merge: true });
            } catch (error) {
                console.error("Error updating presence:", error);
            }
        }


        /** Updates a single pixel in the Firebase document and increments the score. (Requires sign-in) */
        async function updateSinglePixelAndScore(cellIndex, newColor) {
            const user = auth.currentUser;
            if (!user || isUserLocallyBanned()) return; 

            const canvasDocRef = getCanvasDocRef();
            const scoreDocRef = getLeaderboardDocRef(user.uid);

            if (!canvasDocRef || !scoreDocRef) return;

            const cells = gridContainer.querySelectorAll('.pixel-cell');
            let currentColors = Array.from(cells).map(cell => cell.style.backgroundColor || '#ffffff');
            
            if (cellIndex < currentColors.length) {
                currentColors[cellIndex] = newColor;

                const displayName = getDisplayName(user);

                try {
                    // 1. Update Canvas
                    await setDoc(canvasDocRef, {
                        size: gridSize,
                        colors: currentColors,
                        timestamp: serverTimestamp(),
                        lastEditor: user.uid
                    });

                    // 2. Update Leaderboard Score
                    await setDoc(scoreDocRef, {
                        pixelsDrawn: increment(1),
                        lastActivity: serverTimestamp(),
                        displayName: displayName, // Save the determined display name
                    }, { merge: true });
                    
                    // 3. Update Presence (Last Seen)
                    await updatePresence(user, displayName);

                } catch (error) {
                    console.error("Error updating pixel, score, and presence:", error);
                }
            }
        }
        
        /** * Handles painting a cell and updates Firestore/score (Drag and Touch logic). 
         * Determines the correct target if event comes from touch.
         */
        function handlePaint(event) {
            if (!auth.currentUser || isUserLocallyBanned()) {
                // Only show modal on the initial click/touch down
                if (event.type === 'mousedown' || event.type === 'touchstart') {
                    showModal("Access Denied", "You must be signed in (Google, Email, or Anonymous) to draw on the shared canvas.");
                }
                return;
            }

            let target = event.target;
            
            // For touch events (touchmove specifically), find the element under the touch point
            if (event.touches) {
                const touch = event.touches[0];
                if (touch) {
                    // Use document.elementFromPoint to get the element under the moving finger
                    target = document.elementFromPoint(touch.clientX, touch.clientY);
                } else {
                    return; // Exit if no touch data
                }
            }

            if (target && target.classList.contains('pixel-cell')) {
                const cellIndex = parseInt(target.dataset.index);
                
                // Prevent painting the same cell repeatedly during drag/move
                if (cellIndex === lastPaintedIndex && (event.type === 'mousemove' || event.type === 'touchmove')) {
                    return;
                }
                
                // Only paint if the color is actually changing, preventing unnecessary writes
                if (target.style.backgroundColor !== currentColor) {
                    target.style.backgroundColor = currentColor;
                    updateSinglePixelAndScore(cellIndex, currentColor);
                    lastPaintedIndex = cellIndex;
                }
            }
        }

        /** Starts the Firestore real-time listener for the Leaderboard. */
        function startRealTimeLeaderboardSync() {
            if (unsubscribeLeaderboardSnapshot) {
                unsubscribeLeaderboardSnapshot(); // Unsubscribe previous listener if exists
                unsubscribeLeaderboardSnapshot = null;
            }
            
            // CRITICAL FIX: Only subscribe if a user is authenticated (required by security rules)
            if (!auth.currentUser) {
                console.warn("[Firestore] Skipping Leaderboard sync: User is unauthenticated. Waiting for sign-in.");
                leaderboardList.innerHTML = '<li class="text-gray-500 text-sm text-center">Sign in to view the Leaderboard.</li>';
                return;
            }

            const leaderboardCollectionRef = collection(db, 'artifacts', PIXEL_APP_ID, 'public', 'data', LEADERBOARD_COLLECTION);
            const q = query(leaderboardCollectionRef);

            unsubscribeLeaderboardSnapshot = onSnapshot(q, (querySnapshot) => {
                const leaderboardData = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    // Ensure the document has the required fields
                    if (data.pixelsDrawn) {
                        leaderboardData.push(data);
                    }
                });

                // Sort the data locally by pixelsDrawn descending
                leaderboardData.sort((a, b) => (b.pixelsDrawn || 0) - (a.pixelsDrawn || 0));

                // Render the leaderboard
                renderLeaderboard(leaderboardData.slice(0, 10)); // Show top 10
                console.log("[Firestore] Leaderboard updated.", leaderboardData.length, "total entries.");
            }, (error) => {
                console.error(`Firestore Leaderboard Listener Error (User: ${auth.currentUser ? auth.currentUser.uid : 'N/A'}):`, error);
                // This error is expected if the user is not authenticated
                leaderboardList.innerHTML = '<li class="text-gray-500 text-sm text-center">Loading scores failed (Permissions issue).</li>';
            });
        }
        
        /** Renders the leaderboard list. */
        function renderLeaderboard(data) {
            leaderboardList.innerHTML = ''; // Clear existing list

            if (data.length === 0) {
                leaderboardList.innerHTML = '<li class="text-gray-500 text-sm text-center">No contributions yet!</li>';
                return;
            }

            data.forEach((item, index) => {
                const listItem = document.createElement('li');
                const rank = index + 1;
                let colorClass = 'text-gray-700';
                
                // Highlight top ranks
                if (rank === 1) colorClass = 'text-yellow-600 font-extrabold text-lg';
                else if (rank === 2) colorClass = 'text-gray-500 font-bold';
                else if (rank === 3) colorClass = 'text-yellow-800 font-semibold';
                
                const displayName = item.displayName || 'Unknown User';

                listItem.className = `flex justify-between items-center p-3 rounded-lg border-b border-gray-100 transition duration-150 hover:bg-indigo-50 ${colorClass}`;
                listItem.innerHTML = `
                    <span class="font-[Press Start 2P] text-sm w-8 text-left">${rank}.</span>
                    <span class="truncate text-xs flex-grow ml-2">${displayName}</span>
                    <span class="font-bold text-sm ml-4">${item.pixelsDrawn.toLocaleString()}</span>
                `;
                leaderboardList.appendChild(listItem);
            });
        }
        
        /** Starts the Firestore real-time listener for Who's Online. */
        function startRealTimePresenceSync() {
            if (unsubscribePresenceSnapshot) {
                unsubscribePresenceSnapshot();
                unsubscribePresenceSnapshot = null;
            }
            
            // CRITICAL FIX: Only subscribe if a user is authenticated (required by security rules)
            if (!auth.currentUser) {
                console.warn("[Firestore] Skipping Presence sync: User is unauthenticated. Waiting for sign-in.");
                onlineUsersList.innerHTML = '<li class="text-gray-500 text-xs text-center">Sign in to see who is online.</li>';
                onlineCount.textContent = "0 people currently online (not signed in)";
                return;
            }


            const presenceCollectionRef = collection(db, 'artifacts', PIXEL_APP_ID, 'public', 'data', PRESENCE_COLLECTION);
            const q = query(presenceCollectionRef);

            unsubscribePresenceSnapshot = onSnapshot(q, (querySnapshot) => {
                const now = Date.now();
                const activeUsers = [];

                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    // Firestore timestamp objects need to be converted to milliseconds
                    const lastSeenMs = data.lastSeen ? data.lastSeen.toMillis() : 0;
                    
                    // Check if lastSeen is recent enough (within the threshold)
                    if (now - lastSeenMs < ONLINE_THRESHOLD_MS) {
                        activeUsers.push(data);
                    }
                });

                renderPresenceList(activeUsers);
                console.log(`[Firestore] Presence updated. ${activeUsers.length} users deemed active.`);

            }, (error) => {
                console.error(`Firestore Presence Listener Error (User: ${auth.currentUser ? auth.currentUser.uid : 'N/A'}):`, error);
                onlineUsersList.innerHTML = '<li class="text-gray-500 text-xs text-center">Loading online users failed (Permissions issue).</li>';
                onlineCount.textContent = "0 people currently online";
            });
        }

        /** Renders the online user list. */
        function renderPresenceList(users) {
            onlineUsersList.innerHTML = ''; 
            onlineCount.textContent = `${users.length} person${users.length !== 1 ? 's' : ''} currently online`;

            if (users.length === 0) {
                onlineUsersList.innerHTML = '<li class="text-gray-500 text-xs text-center">No one active recently.</li>';
                return;
            }

            // Sort alphabetically by display name
            users.sort((a, b) => (a.displayName || '').localeCompare(b.displayName || ''));

            const currentUserId = auth.currentUser ? auth.currentUser.uid : null;

            users.forEach((user) => {
                const listItem = document.createElement('li');
                
                // Highlight the current user
                const isCurrentUser = user.uid === currentUserId;
                const highlightClass = isCurrentUser ? 'bg-green-50 font-bold border-green-300' : 'border-gray-50 hover:bg-gray-50';

                const status = isUserLocallyBanned() ? ' (BANNED)' : '';
                const icon = isUserLocallyBanned() ? 'üö´' : 'üü¢';
                const statusColor = isUserLocallyBanned() ? 'text-red-500' : 'text-green-500';


                listItem.className = `flex items-center text-xs p-1 rounded-md transition duration-150 border ${highlightClass}`;
                listItem.innerHTML = `
                    <span class="mr-2 ${statusColor}">${icon}</span>
                    <span class="truncate">${user.displayName}</span>
                    <span class="text-gray-400 italic ml-1">${status}</span>
                `;
                onlineUsersList.appendChild(listItem);
            });
        }



        // --- Event Listeners and Initialization ---

        window.onload = () => {
            setupFirebase();
            
            // Color picker
            colorPicker.addEventListener('change', (e) => {
                currentColor = e.target.value;
            });

            // Clear button
            clearBtn.addEventListener('click', async () => {
                if (!auth.currentUser || isUserLocallyBanned()) {
                    showModal("Access Denied", "You must be signed in and not banned to clear the canvas.");
                    return;
                }
                
                if (auth.currentUser.isAnonymous) {
                     showModal("Clear Denied", "Only authenticated users (Google or Email) are permitted to clear the entire canvas.");
                     return;
                }
                
                // Using a custom modal replacement for confirm()
                const promptClear = () => {
                    showModal("Confirm Clear", "Are you sure you want to clear the entire canvas? This action cannot be undone.");
                    
                    // Replace the standard close button with confirmation buttons
                    const standardCloseBtn = modalContent.querySelector('#modal-close-btn-standard');
                    if (standardCloseBtn) {
                        standardCloseBtn.remove();
                    }
                    
                    const confirmClearBtn = document.createElement('button');
                    confirmClearBtn.textContent = 'Yes, Clear Canvas';
                    confirmClearBtn.className = 'w-full py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition btn-style mt-4';
                    
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.className = 'w-full py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition btn-style mt-2';

                    modalContent.appendChild(confirmClearBtn);
                    modalContent.appendChild(cancelBtn);
                    
                    confirmClearBtn.onclick = async () => {
                        closeModal();
                        const docRef = getCanvasDocRef();
                        if (docRef) {
                            try {
                                await setDoc(docRef, {
                                    size: gridSize,
                                    colors: Array(gridSize * gridSize).fill('#ffffff'),
                                    timestamp: serverTimestamp(),
                                    lastEditor: auth.currentUser.uid
                                });
                                showModal("Canvas Cleared", "The canvas has been reset to white.");
                            } catch(e) {
                                console.error("Error clearing canvas:", e);
                                showModal("Error", "Failed to clear the canvas. Check console for details.");
                            }
                        }
                    };
                    cancelBtn.onclick = closeModal;
                };

                promptClear();
            });


            // Auth Button Listeners
            signUpBtn.addEventListener('click', handleEmailSignUp);
            emailSignInBtn.addEventListener('click', handleEmailSignIn);
            passwordResetBtn.addEventListener('click', handlePasswordReset);
            googleSignInBtn.addEventListener('click', handleGoogleSignIn);
            anonymousSignInBtn.addEventListener('click', handleAnonymousSignIn);
            signOutBtn.addEventListener('click', handleSignOut);
            resignInBtn.addEventListener('click', handleResignInAttempt);

            // Modal Close Listener (for non-confirmation modals)
            modalContainer.addEventListener('click', (e) => {
                if (e.target === modalContainer) closeModal();
            });

            // Drawing Logic (Mouse/Touch events)
            gridContainer.addEventListener('mousedown', (e) => {
                isDrawing = true;
                handlePaint(e); 
            });

            gridContainer.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    handlePaint(e);
                }
            });

            gridContainer.addEventListener('mouseup', () => {
                isDrawing = false;
                lastPaintedIndex = -1; 
            });

            // Handle touch events for mobile drawing
            gridContainer.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                isDrawing = true;
                handlePaint(e);
            }, { passive: false });

            gridContainer.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                if (isDrawing) {
                    handlePaint(e);
                }
            }, { passive: false });

            gridContainer.addEventListener('touchend', () => {
                isDrawing = false;
                lastPaintedIndex = -1;
            });

            // Prevent drag from selecting canvas elements
            gridContainer.addEventListener('dragstart', (e) => e.preventDefault());
        };
    </script>
</body>
</html>
