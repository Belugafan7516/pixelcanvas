<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Pixel Art</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom scrollbar for the canvas container */
        .canvas-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        .canvas-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .canvas-container::-webkit-scrollbar-thumb {
            background: #a8a29e; /* stone-400 */
            border-radius: 10px;
        }
        .canvas-container::-webkit-scrollbar-thumb:hover {
            background: #78716c; /* stone-500 */
        }
        /* Ensure touch actions are handled correctly on canvas */
        canvas {
            touch-action: none;
            transform-origin: top left;
        }
    </style>
</head>
<body class="min-h-screen bg-gray-100 flex flex-col items-center p-2 sm:p-4 font-sans">

    <!-- Header -->
    <header class="w-full max-w-4xl text-center mb-6">
        <h1 class="text-3xl font-extrabold text-gray-800">Collaborative Pixel Art (1000x1000)</h1>
        <p class="text-gray-600 mt-1">1x1 Brush, Real-Time Sync, and Pixel Leaderboard.</p>
        <div id="status-message" class="text-sm font-semibold text-gray-700 mt-2 p-2 rounded-lg bg-yellow-100">
            Connecting...
        </div>
    </header>

    <!-- Controls and Leaderboard Panel -->
    <div class="bg-white p-4 rounded-xl shadow-xl w-full max-w-4xl mb-6 grid grid-cols-1 md:grid-cols-3 gap-4">
        
        <!-- 1. Color and Zoom Controls (Col 1) -->
        <div class="flex flex-col space-y-3 p-3 bg-gray-50 rounded-lg shadow-inner">
            <div class="flex items-center space-x-2">
                <i data-lucide="mouse-pointer-2" class="w-5 h-5 text-gray-600"></i>
                <span class="text-sm font-semibold text-gray-700">Brush Color:</span>
            </div>
            <div id="color-palette" class="flex flex-wrap gap-2">
                <!-- Color buttons will be injected by JS -->
            </div>

            <div class="pt-2">
                <div class="flex items-center space-x-2 mb-1">
                    <i data-lucide="zoom-in" class="w-5 h-5 text-gray-600"></i>
                    <label for="zoom-input" id="zoom-label" class="text-sm font-semibold text-gray-700">Zoom (1x)</label>
                </div>
                <input
                    id="zoom-input"
                    type="range"
                    min="1"
                    max="5"
                    step="0.5"
                    value="1"
                    class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg"
                    disabled
                />
            </div>
        </div>

        <!-- 2. Clear Button & User ID (Col 2) -->
        <div class="flex flex-col space-y-3 p-3 bg-gray-50 rounded-lg shadow-inner">
            <div class="flex items-center space-x-2">
                <i data-lucide="users" class="w-5 h-5 text-gray-600"></i>
                <span class="text-sm font-semibold text-gray-700">User Information</span>
            </div>
            <p class="text-xs text-gray-500 break-words font-mono">
                ID: <strong id="user-id-display">N/A (Please login)</strong>
            </p>
            <hr class="border-gray-200" />
            
            <button
                id="clear-button"
                disabled
                class="w-full px-4 py-2 font-bold rounded-lg shadow-md flex items-center justify-center transition duration-200 text-sm bg-gray-400 text-gray-700 cursor-not-allowed"
            >
                <i data-lucide="refresh-ccw" class="w-4 h-4 mr-2"></i>
                <span>Loading...</span>
            </button>
            <p id="cooldown-timer-text" class="text-xs text-red-500 text-center font-medium hidden"></p>
        </div>

        <!-- 3. Leaderboard (Col 3) -->
        <div class="flex flex-col space-y-2 p-3 bg-indigo-50 rounded-lg shadow-inner">
            <div class="text-lg font-bold text-indigo-700 border-b border-indigo-300 pb-1 flex items-center">
                <i data-lucide="users" class="w-5 h-5 mr-2"></i> Top Pixelers
            </div>
            <ol id="leaderboard-list" class="space-y-1 text-sm">
                <li class="text-gray-500 italic">Loading scores...</li>
            </ol>
        </div>
    </div>

    <!-- Canvas Display Area - Fixed 1000x1000 viewport with scrolling for zoom -->
    <div 
        class="canvas-container p-1 bg-white border-4 border-teal-500 rounded-xl shadow-2xl overflow-scroll"
        style="max-width: 100vw; max-height: calc(100vh - 350px);">
        <canvas
            id="pixel-canvas"
            width="1000"
            height="1000"
            class="block cursor-crosshair transition-transform duration-100"
            style="width: 1000px; height: 1000px;"
        >
            Your browser does not support the HTML canvas tag.
        </canvas>
    </div>

    <!-- 3. Load Firebase and our Application Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, runTransaction, collection, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Constants ---
        const FIXED_WIDTH = 1000;
        const FIXED_HEIGHT = 1000;
        const FIXED_PIXEL_SIZE = 1;
        const COOLDOWN_SECONDS = 3600;
        const COLORS = [
            '#dc2626', '#2563eb', '#05969a', '#f59e0b', '#7c3aed', '#111827', '#ffffff'
        ];

        // --- Global State ---
        let currentColor = COLORS[2];
        let isDrawing = false;
        let userId = null;
        let isAuthReady = false;
        let cooldownTimeRemaining = 0;
        let zoomLevel = 1;
        let cooldownInterval = null;

        // --- DOM Element Refs ---
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const zoomInput = document.getElementById('zoom-input');
        const zoomLabel = document.getElementById('zoom-label');
        const colorPalette = document.getElementById('color-palette');
        const clearButton = document.getElementById('clear-button');
        const clearButtonText = clearButton.querySelector('span');
        const clearButtonIcon = clearButton.querySelector('i');
        const cooldownTimerText = document.getElementById('cooldown-timer-text');
        const userIdDisplay = document.getElementById('user-id-display');
        const leaderboardList = document.getElementById('leaderboard-list');

        // --- Firebase Refs ---
        let db, auth, canvasDocRef, leaderboardDocRef;
        
        // --- Drawing Buffers ---
        let unsavedPixels = {};
        let unsavedScore = 0;
        let lastDrawnCell = null;

        // --- Utility Functions ---
        const throttle = (fn, delay) => {
            let last = 0;
            let timeoutId = null;
            return (...args) => {
                const now = Date.now();
                if (now - last < delay) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        last = Date.now();
                        fn(...args);
                    }, delay - (now - last));
                } else {
                    last = now;
                    fn(...args);
                }
            };
        };

        const formatTime = (seconds) => {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        };

        // --- UI Rendering Functions ---
        
        function renderColorPalette() {
            colorPalette.innerHTML = ''; // Clear existing
            COLORS.forEach(color => {
                const button = document.createElement('button');
                button.className = `w-8 h-8 rounded-lg border-2 transition-all duration-150 ${
                    currentColor === color 
                        ? 'shadow-lg ring-4 ring-offset-2 ring-teal-500 scale-110' 
                        : 'border-gray-300 hover:scale-105'
                } ${color === '#ffffff' ? 'border-gray-500' : ''}`;
                button.style.backgroundColor = color;
                button.title = color === '#ffffff' ? 'Eraser' : color;
                button.disabled = !isAuthReady;
                
                button.addEventListener('click', () => {
                    currentColor = color;
                    renderColorPalette(); // Re-render to show selection
                });
                colorPalette.appendChild(button);
            });
        }
        
        function updateCooldownUI() {
            const isCooldownActive = cooldownTimeRemaining > 0;
            
            if (isCooldownActive) {
                clearButton.disabled = true;
                clearButton.classList.add('bg-gray-400', 'text-gray-700', 'cursor-not-allowed');
                clearButton.classList.remove('bg-red-500', 'text-white', 'hover:bg-red-600');
                clearButtonText.textContent = `Cooldown: ${formatTime(cooldownTimeRemaining)}`;
                cooldownTimerText.textContent = `Next clear available in ${formatTime(cooldownTimeRemaining)}.`;
                cooldownTimerText.classList.remove('hidden');
            } else {
                clearButton.disabled = !isAuthReady;
                clearButton.classList.remove('bg-gray-400', 'text-gray-700', 'cursor-not-allowed');
                if (isAuthReady) {
                    clearButton.classList.add('bg-red-500', 'text-white', 'hover:bg-red-600');
                }
                clearButtonText.textContent = 'Clear Canvas (1h Cooldown)';
                cooldownTimerText.classList.add('hidden');
            }
        }

        function startCooldownTimer() {
            if (cooldownInterval) clearInterval(cooldownInterval);
            if (cooldownTimeRemaining > 0) {
                cooldownInterval = setInterval(() => {
                    cooldownTimeRemaining = Math.max(0, cooldownTimeRemaining - 1);
                    updateCooldownUI();
                    if (cooldownTimeRemaining === 0) {
                        clearInterval(cooldownInterval);
                    }
                }, 1000);
            }
            updateCooldownUI();
        }

        function renderLeaderboard(scoresData) {
            const sortedLeaderboard = Object.entries(scoresData)
                .map(([uid, score]) => ({ uid, score }))
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);
            
            if (sortedLeaderboard.length === 0) {
                leaderboardList.innerHTML = '<li class="text-gray-500 italic">Start drawing to climb the ranks!</li>';
                return;
            }

            leaderboardList.innerHTML = sortedLeaderboard.map((item, index) => {
                const isCurrentUser = item.uid === userId;
                const userClass = isCurrentUser ? 'font-bold text-indigo-700' : 'text-gray-700';
                return `
                    <li class="flex justify-between items-center ${userClass}">
                        <span>${index + 1}. ${item.uid.substring(0, 8)}...</span>
                        <span class="px-2 py-0.5 bg-indigo-200 rounded-full text-xs">${item.score.toLocaleString()}</span>
                    </li>
                `;
            }).join('');
        }

        function setUIEnabled(enabled) {
            isAuthReady = enabled;
            zoomInput.disabled = !enabled;
            clearButton.disabled = enabled ? cooldownTimeRemaining > 0 : true;
            renderColorPalette();
            updateCooldownUI();
        }

        // --- Canvas & Drawing Logic ---

        function initializeCanvas(pixelsMap = {}) {
            ctx.fillStyle = '#f3f4f6'; // Light gray background
            ctx.fillRect(0, 0, FIXED_WIDTH, FIXED_HEIGHT);
            
            Object.entries(pixelsMap).forEach(([key, color]) => {
                const [x, y] = key.split('_').map(Number);
                if (color !== '#f3f4f6') { // Only draw colored pixels
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, FIXED_PIXEL_SIZE, FIXED_PIXEL_SIZE);
                }
            });
        }
        
        function getSnappedCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = event.clientX || (event.touches?.[0]?.clientX);
            const clientY = event.clientY || (event.touches?.[0]?.clientY);

            if (clientX === undefined || clientY === undefined) return null;

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            
            const snappedX = Math.floor(x / FIXED_PIXEL_SIZE) * FIXED_PIXEL_SIZE;
            const snappedY = Math.floor(y / FIXED_PIXEL_SIZE) * FIXED_PIXEL_SIZE;
            
            const cellId = `${snappedX}_${snappedY}`;
            return { snappedX, snappedY, cellId };
        }

        function executeDraw(snappedX, snappedY) {
            const cellId = `${snappedX}_${snappedY}`;
            
            ctx.fillStyle = currentColor;
            ctx.fillRect(snappedX, snappedY, FIXED_PIXEL_SIZE, FIXED_PIXEL_SIZE);
            
            unsavedPixels[cellId] = currentColor;
            unsavedScore += 1;
            
            throttledSave();
        }
        
        function startDrawing(event) {
            event.preventDefault();
            if (!isAuthReady) return;
            const coords = getSnappedCoordinates(event);
            if (!coords) return;

            executeDraw(coords.snappedX, coords.snappedY);
            lastDrawnCell = coords.cellId;
            isDrawing = true;
        }

        function draw(event) {
            if (!isDrawing) return;
            event.preventDefault();
            const coords = getSnappedCoordinates(event);
            if (!coords) return;

            if (coords.cellId !== lastDrawnCell) {
                executeDraw(coords.snappedX, coords.snappedY);
                lastDrawnCell = coords.cellId;
            }
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                lastDrawnCell = null;
                throttledSave(); // Final save
            }
        }

        // --- Firestore Logic ---

        const saveCanvasAndScore = async () => {
            if (!db || !canvasDocRef || !leaderboardDocRef || !userId) return;

            const pixelsToSave = { ...unsavedPixels };
            const scoreIncrement = unsavedScore;

            if (Object.keys(pixelsToSave).length === 0 && scoreIncrement === 0) return;

            unsavedPixels = {};
            unsavedScore = 0;
            
            try {
                await runTransaction(db, async (transaction) => {
                    const canvasDoc = await transaction.get(canvasDocRef);
                    const leaderboardDoc = await transaction.get(leaderboardDocRef);
                    
                    // --- Canvas Update ---
                    const canvasData = canvasDoc.exists() ? canvasDoc.data() : {};
                    const currentPixelsString = canvasData.coloredPixels || '{}';
                    let currentPixels = {};
                    try { currentPixels = JSON.parse(currentPixelsString); } catch(e) {}

                    const mergedPixels = { ...currentPixels, ...pixelsToSave };
                    
                    Object.keys(mergedPixels).forEach(key => {
                        if (mergedPixels[key] === '#ffffff' || mergedPixels[key] === '#f3f4f6') {
                            delete mergedPixels[key];
                        }
                    });

                    transaction.set(canvasDocRef, {
                        coloredPixels: JSON.stringify(mergedPixels),
                        lastDrawnAt: Date.now(),
                    }, { merge: true });

                    // --- Leaderboard Update ---
                    const scores = leaderboardDoc.exists() ? leaderboardDoc.data() : {};
                    const currentScore = scores[userId] || 0;
                    
                    transaction.set(leaderboardDocRef, {
                        [userId]: currentScore + scoreIncrement,
                    }, { merge: true });
                });
            } catch (e) {
                console.error("Transaction failed:", e);
                // Re-buffer
                unsavedPixels = { ...unsavedPixels, ...pixelsToSave };
                unsavedScore += scoreIncrement;
            }
        };

        const throttledSave = throttle(saveCanvasAndScore, 200);

        async function clearCanvas() {
            if (cooldownTimeRemaining > 0 || !isAuthReady) return;
            if (!db || !canvasDocRef || !leaderboardDocRef || !userId) return;

            statusMessage.textContent = 'Clearing canvas and resetting leaderboard...';
            try {
                await setDoc(canvasDocRef, {
                    coloredPixels: JSON.stringify({}),
                    lastClearedAt: Date.now(),
                    lastClearedBy: userId,
                }, { merge: true });

                await setDoc(leaderboardDocRef, {}); // Clear all scores
                statusMessage.textContent = 'Canvas cleared and leaderboard reset!';
            } catch (e) {
                console.error("Error clearing canvas:", e);
                statusMessage.textContent = `Clear failed: ${e.code}`;
            }
        }

        function setupFirebaseListeners() {
            if (!isAuthReady || !db) return;
            statusMessage.textContent = 'Loading shared canvas and scores...';

            // Canvas Listener
            onSnapshot(canvasDocRef, (docSnap) => {
                const data = docSnap.exists() ? docSnap.data() : {};
                
                const coloredPixelsString = data.coloredPixels || '{}';
                let pixelsMap = {};
                try { pixelsMap = JSON.parse(coloredPixelsString); } catch (e) {}
                initializeCanvas(pixelsMap);

                const lastClearedAt = data.lastClearedAt || 0;
                const timeSinceLastClear = (Date.now() - lastClearedAt) / 1000;
                cooldownTimeRemaining = Math.round(Math.max(0, COOLDOWN_SECONDS - timeSinceLastClear));
                startCooldownTimer();
                
                statusMessage.textContent = 'Ready. Start drawing!';
            }, (error) => {
                console.error("Firestore Canvas Snapshot Error:", error);
                statusMessage.textContent = `Real-time canvas error: ${error.code}`;
            });

            // Leaderboard Listener
            onSnapshot(leaderboardDocRef, (docSnap) => {
                const scoresData = docSnap.exists() ? docSnap.data() : {};
                renderLeaderboard(scoresData);
            }, (error) => {
                console.error("Firestore Leaderboard Snapshot Error:", error);
            });
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            statusMessage.textContent = 'Connecting to Firebase...';

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            
            let firebaseConfig = null;
            try {
                // Check for env variable first (won't work in this snippet, but good practice)
                if (typeof process !== 'undefined' && process.env.REACT_APP_FIREBASE_CONFIG) {
                    firebaseConfig = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);
                } else if (typeof __firebase_config !== 'undefined') {
                    firebaseConfig = JSON.parse(__firebase_config);
                }
            } catch (e) {
                console.error("Failed to parse Firebase config", e);
                statusMessage.textContent = "Error: Firebase configuration is invalid.";
                return;
            }

            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

            if (!firebaseConfig) {
                statusMessage.textContent = "Error: Firebase configuration missing. Login is REQUIRED.";
                return;
            }
            
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                setLogLevel('Debug');

                const rootPath = 'artifacts';
                const publicPath = 'public';
                const dataPath = 'data';
                
                canvasDocRef = doc(db, rootPath, appId, publicPath, dataPath, 'pixel_art', 'main_canvas');
                leaderboardDocRef = doc(db, rootPath, appId, publicPath, dataPath, 'leaderboard', 'scores');

                // Auth logic
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        userIdDisplay.textContent = user.uid;
                        setUIEnabled(true);
                        setupFirebaseListeners();
                    } else {
                        userId = null;
                        userIdDisplay.textContent = 'N/A (Please login)';
                        setStatusMessage('Login is REQUIRED to draw and view the collaborative canvas.');
                        setUIEnabled(false);
                        signIn(); // Try to sign in
                    }
                });

                const signIn = async () => {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                        statusMessage.textContent = `Authentication failed: ${error.code}`;
                    }
                };
                
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                statusMessage.textContent = `Initialization failed: ${error.message}`;
            }

            // --- Initial UI Setup & Event Listeners ---
            initializeCanvas();
            renderColorPalette();
            updateCooldownUI();
            
            // Activate Lucide Icons
            lucide.createIcons();
            
            // Canvas Listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchend', stopDrawing, { passive: false });
            canvas.addEventListener('touchcancel', stopDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });

            // Control Listeners
            zoomInput.addEventListener('input', (e) => {
                zoomLevel = parseFloat(e.target.value);
                zoomLabel.textContent = `Zoom (${zoomLevel}x)`;
                canvas.style.width = `${FIXED_WIDTH * zoomLevel}px`;
                canvas.style.height = `${FIXED_HEIGHT * zoomLevel}px`;
            });

            clearButton.addEventListener('click', clearCanvas);
        });

    </script>
</body>
</html>

